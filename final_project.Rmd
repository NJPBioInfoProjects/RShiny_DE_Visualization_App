---
title: "final_project_work"
output: html_document
date: "2024-11-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```{r}
#clean the data
library('tidyverse')
```

Okay, lets do some fgsea
```{r}
# de_results <- read_csv("data/deseq_diff_exp_res.csv")
# colnames(de_results)[1] <- "gene"
# 
# gene_ranking <- de_results %>%
#   
#   arrange(desc(log2FoldChange)) %>%
#   
#   drop_na(log2FoldChange) %>%
#   
#   pull(log2FoldChange)
# 
# names(gene_ranking) <- de_results %>%
#   arrange(desc(log2FoldChange)) %>%
#   drop_na(log2FoldChange) %>%
#   pull(gene)
# 
# head(gene_ranking)
```
```{r}

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("msigdbr")

```
```{r}
library(msigdbr)
library(tidyverse)

# Load gene sets for Homo sapiens
gene_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  split(x = .$ensembl_gene, f = .$gs_name)  # Use Ensembl gene IDs


```

```{r}

# Assuming 'de_results' is your DESeq2 results

de_results <- read_csv("data/deseq_diff_exp_res.csv")
colnames(de_results)[1] <- "gene"
gene_ranking <- de_results %>%
  filter(!is.na(log2FoldChange)) %>%        # Exclude rows with NA values
  arrange(desc(log2FoldChange)) %>%         # Rank by log2FC
  pull(log2FoldChange)

# Assign Ensembl IDs as names
names(gene_ranking) <- de_results$gene  # 'gene' column should have ENSG IDs

# Check structure
str(gene_ranking)
head(gene_ranking)
```
```{r}
# Remove version numbers from Ensembl IDs
names(gene_ranking) <- sub("\\..*", "", names(gene_ranking))

# Verify updated names
head(names(gene_ranking))

```

```{r}
library(fgsea)

# Add jitter to handle ties
gene_ranking <- jitter(gene_ranking, amount = 1e-5)

# Run fgsea
fgsea_results <- fgsea(
  pathways = gene_sets,       # Gene sets with Ensembl IDs
  stats = gene_ranking,       # Your ranked genes
  minSize = 15,               # Minimum gene set size
  maxSize = 500,              # Maximum gene set size
  nperm = 1000                # Number of permutations
)

# Convert to data frame
fgsea_results_df <- as.data.frame(fgsea_results)

fgsea_results_df$leadingEdge <- sapply(fgsea_results_df$leadingEdge, function(x) paste(x, collapse = ";"))

# View results
head(fgsea_results_df)



# Save results
write.csv(fgsea_results_df, "fgsea_results.csv", row.names = FALSE)


#str(fgsea_results_df)


```
```{r}

fgsea_res <- fgsea_results_df %>%
  arrange(padj)
head(fgsea_res, 10)
```

```{r}
# Load necessary library
library(tidyverse)

meta <- read.csv("data/sample_metadata 2.csv", row.names = 1)

```

```{r}

# Load necessary libraries
library(DESeq2)

# Set file path
file_path <- "data/raw_counts.tsv"

# Read in raw counts
raw_counts <- read.table(file_path, header = TRUE, sep = "\t", row.names = 1)

# Create a DESeq2 dataset
# Assuming all samples belong to the same condition for normalization
col_data <- data.frame(condition = factor(rep(1, ncol(raw_counts))))
dds <- DESeqDataSetFromMatrix(countData = raw_counts, colData = col_data, design = ~ 1)

# Perform normalization
dds <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized = TRUE)

# Save normalized counts as CSV
write.csv(as.data.frame(normalized_counts), "normalized_counts.csv", row.names = TRUE)

cat("Normalized counts saved to normalized_counts.csv")


```